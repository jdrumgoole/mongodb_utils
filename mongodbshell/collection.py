import pymongo


@staticmethod
def has_attr(col, name):
    '''
    Can't use the built in hasattr to check if name is a member
    of a collection object as built hasattr uses getattr and in
    the Collection object getattr is overwritten to allow collections
    to be generated by specifying col.<name>.

    :param col: a pymongo.Collection object
    :param name: a candidate name
    :return: the specified object or None
    '''

    if name in dir(col):
        return getattr(col, name)
    else:
        return None

class MSHMongoClient(pymongo.MongoClient):
    def __init__(self, *args, **kwargs):
        super.__init__(*args, **kwargs)

    def __getattr__(self, item):
        pass

    def __getitem__(self, item):
        pass

class MSHDatabase(pymongo.Database):
    def __init__(self, *args, **kwargs):
        super.__init__(*args, **kwargs)

    def __getattr__(self, item):
        return MS

    def __getitem__(self, item):
        pass

class MSHCollection(pymongo.Collection):

    def __init__(self, *args, **kwargs):
        super.__init__(*args, **kwargs)

    def __getattr__(self, item):
        pass

    def __getitem__(self, item):
        pass

    def __getattr__(self, name, *args, **kwargs):
        '''
        Call __getattr__ if we specify members that don't exist. The
        goal here is to pass any function not directly implemented
        by this class straight up to pymongo.Collection.

        Here we intercept the function lookup invoked of the
        mongodbshell.MongoClient object and use it to invoke the
        pymongo.Collection class directly. The nested inner function
        is required to capture the parameters correctly.

        :param name: the method or property that doesn't exist.
        :param args: args passed in by invoker
        :param kwargs: kwargs passed in by invoker
        :return: Results of call target method
        '''
        if self.has_attr(self, name):
            attr = getattr(self.collection, name)

        else:
            reporter = ErrorReporter(name)
            attr = reporter.error_msg
            print(f"name: {name}")

        def make_invoker(invoker):
            #@handle_exceptions
            if callable(invoker):
                def inner_func(*args, **kwargs):
                    print(f"inner func({args}, {kwargs})")
                    result = invoker(*args, **kwargs)
                    if type(result) in [pymongo.command_cursor.CommandCursor, pymongo.cursor.Cursor]:
                        self.print_cursor(result)
                    elif type(result) is dict:
                        self._pager.paginate_doc(result)
                    else:
                        print(f"type result: {type(result)}")
                        print(f"result: {result}")
                        return result
                return inner_func
            else:
                return invoker

        print(f"Calling make_invoker({attr})")
        return make_invoker(attr)
